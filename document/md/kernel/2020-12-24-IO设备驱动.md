#### I/O设备驱动



| 作者                 | 时间       | QQ技术交流群                      |
| -------------------- | ---------- | --------------------------------- |
| perrynzhou@gmail.com | 2020/12/01 | 中国开源存储技术交流群(672152841) |

- 一个简化的IO设备包括三个寄存器;一个状态寄存器用于读取并查看设备当前状态；一个命令寄存器，用于通知设备执行某个具体的任务；一根数据寄存器，将数据传给设备或者从设备接收数据，通过读写这些寄存器，OS可以控制设备行为。
  - 操作系统反复读取状态寄存器，等待设备进去可以接收命令的就绪状态，这个也叫寻轮设备(polling，轮询设备就是问设备当前做什么)
  - 操作系统下发数据到数据结存器，比如应用多次写入到磁盘,将一个磁盘块(4K)传递给设备，如果CPU参与了数据移动(这个也叫Programmed I/O).
  - 操作系统将命令写入到命令寄存器，这样设备就知道数据已经准备好了，它应该执行命令。
  - 最后操作系统再次通过不断轮询设备，等待并判断设备是否执行完成命令。
- 简化版本的设备采用轮询，这样的协议简单有效，但是存在一个问题就是轮询的过程过于低效,在等待设备执行完成命令时浪费了大量CPU时间,可以利用中断减少CPU的开销
  - 利用中断减少CPU的开销，有了中断就不需要轮询设备，而是想设备发出一个请求，然后让对应的进程睡眠，切换执行其他的进程任务，当设备完成自身操作，会抛出一个硬件中断，引发CPU跳转执行操作系统预先定义好的中断程序。
  - 中断程序师一小段操作系统系统代码，它会结束之前的请求并且唤醒等待IO的进程继续执行
  - 中断方式也并非总是组价方案,例如一个高性能设备（nvme ssd）,它处理请求的很快，通常CPU第一次轮询时就可以返回结果。此时如果使用中断，反而使得系统变慢，切换到其他进程，处理中断，再切换回来之前的进程代价不小。如果设备非常快，建议最后使用寻轮而非中断。如果设备比较慢，使用中断比较合理

- 利用DMA进行高效数据传输
  - 进程在运行过程中需要向磁盘写入一些数据，因此进行I/O操作，将数据从内存拷贝到磁盘，拷贝结束后，磁盘上的I/O操作开始执行，此时CPU才可以处理其他请求，使用programming I/O方式，CPU的时间会浪费在向设备传输数据或者从设备传出数据的过程中，CPU利用率非常低，唯一的解决方案是使用DMA。
  - DMA引擎是一个特殊的设备,它可以协调完成内存和设备之间的数据数据传输，而不需要CPU介入。
  - DMA按照如下的步骤进行工作
    - 为了能够将数据传送给设备，操作系统会通过编程告诉DMA的引擎数据的内存位置、要拷贝的带下、要拷贝到哪个设备
    - 然后操作系统可以处理其他请求了，当DMA的任务完成后,DMA控制器会抛出一个中断老告诉操作系统已经完成数据的传输。整个过程中，数的拷贝工作都由DMA控制器来完成，CPU在此时是空闲的，操作系统可以让CPU做其他的事情
- 硬件设备之间的交互方法
  - 在x86上in和out的I/O指令用来与设备进行交互，当需要发送数据给设备时,调用者指定一个存入数据的特定寄存器和一个代表设备的特定端口，执行这个指令就能完成任务。这个是os的特权指令，是os唯一直接和设备交互的实体
  - 其次就是内存映射IO，通过这种方式，硬件将设备寄存器作为内存地址提供。当需要访问涉笔寄存器时候，操作系统读取或者写入该内存地址(寄存器映射后的内存地址)，然后硬件将读取或者写入转义到设备上，而不是物理内存

- 设备驱动
  - 在最底层，操作系统的一部分软件清除的知道设备如何工作，这部分的软件称为设备驱动，所有设备交互的细节都封装在其中
  - Linux文件系统完全不清楚它使用时什么类型的磁盘，它只需要简单向通用块设备层发送读写请求即可，块设备层将这些请求路由给对应的设备驱动，然后设备驱动来完成真正的底层操作
  - Linux内核实现中70%都是设备驱动代码，驱动程序在整个内核代码中的占比非常大