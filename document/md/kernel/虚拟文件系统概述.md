
## 虚拟文件系统概述

| 作者                 | 时间       | QQ技术交流群                      |
| -------------------- | ---------- | --------------------------------- |
| perrynzhou@gmail.com | 2020/09/23 | 中国开源存储技术交流群(672152841) |


### vfs虚拟文件系统
- 虚拟文件系统提供一组系统调用，对各种不同的文件系统进行操作，对用户影藏了各种不同文件系统的实现细节，为用户进程提供一个统一的、抽象的、虚拟的文件系统。
- vfs包含如下组件对象,它们分别是文件对象(进程已打开的文件信息)、目录项对象(存放文件名称和对应文件关联信息)、索引点对象(存放物理文件元数据信息)、超级块对象(存放对应的已安装和挂载的信息)；索引节点inode唯一的代表物理文件，目录项dentry将文件组织成目录树状结构，文件对象file是进程访问文件的接口现场；超级块(super_block)则是记录整个文件系统的全局信息。vfs使用super_operations、inode_operations、dentry_operations、file_operations来保存vfs4中对象的操作函数表
  ![filesystem-relation](../images/filesystem-relation.jpg)
- vfs中文件对象针对文件操作核心结构是file_operations数据结构,每个文件系统都有自己的file_operations结构，file_operations实际是一个函数跳转表，每个函数都指向具体文件系统的实现的函数，比如xfs文件系统，read操作执行xfs的read函数。这个结构设计类似于设计模式中的工厂设计模式
  ![filesystem-relation](../images/filesytem-overview.jpg)
```
//vfs提供的文件操作接口，其中struct file是每个进程打开的文件指针
//定义在linux-5.8.8/include/linux/fs.h
struct file_operations {
	struct module *owner;
	loff_t (*llseek) (struct file *, loff_t, int);
	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
	ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
	ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
	int (*iopoll)(struct kiocb *kiocb, bool spin);
	int (*iterate) (struct file *, struct dir_context *);
	int (*iterate_shared) (struct file *, struct dir_context *);
	//用于poll/select系统调用，实现同步的IO多路复用
	__poll_t (*poll) (struct file *, struct poll_table_struct *);
	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
	int (*mmap) (struct file *, struct vm_area_struct *);
	unsigned long mmap_supported_flags;
	int (*open) (struct inode *, struct file *);
	int (*flush) (struct file *, fl_owner_t id);
	int (*release) (struct inode *, struct file *);
	int (*fsync) (struct file *, loff_t, loff_t, int datasync);
	int (*fasync) (int, struct file *, int);
	int (*lock) (struct file *, int, struct file_lock *);
	//忽略
} __randomize_layout;
```
![vfs-intro](../images/vfs-intro.jpg)
- 进程和文件相连,即进程已经打开的文件,归属于进程所有。这也代表这struct file 和struct task_struct存在一定的关系。那task_struct怎么表示的呢？task_struct也是linux进程表示的形式。
```
//定义在linux-5.8.8/include/linux/sched.h
struct task_struct {
    /* 忽略  */
	//具体文件系统的信息
	struct fs_struct		*fs;
	//进程打开的文件描述符表，系统调用open时候返回的是files的索引下标
	struct files_struct		*files;
	/* 忽略  */

};

//定义在linux-5.8.8/include/linux/fs_struct.h
//open一个文件返回的fd,在实际文件读写中用fd去内核找到这个fs_struct进行操作
struct fs_struct {
	int users;
	spinlock_t lock;
	seqcount_t seq;
	int umask;
	int in_exec;
	//path是当前进程打开的目录
	//pwd是当前进程所在的目录;root是这个进程的根目录
	struct path root, pwd;
} __randomize_layout;

```
- 从task_struct结构可以出，files是一个结构数组，进程打开一个文件后，进程通过一个“文件描述符"fd来访问这个文件，这个fd实际task_struct中files数组的下标，每个files_struct结构中有一个。
- file_operations操作函数中参数struct file ，包括了dentry和inode.inode记录着文件在存储介质上的未知和分布信息.如何简单说了file_operations操作文件函数的file参数相关涉及的结构体说明
```
//定义在linux-5.8.8/include/linux/fs.h
//file对象的没有单独磁盘镜像，它的内容一部分从索引节点获取，一部分从超级块/索引节点对象来获取；
//file涉及文件内容的操作,file是进程所打开文件状态相关的信息,用户进程进行文件操作的入口,每一个被打开的磁盘文件都会建立一个file对象，它指出磁盘文件所在、与该文件进行交互操作的函数以及相关的控制管理属性
struct file {
	/****忽略其中不关注的字段***/
	//文件路径信息,f_path成员建立与目录项的联系
	struct path		f_path;
	//文件inode信息
	struct inode		*f_inode;	/* cached value */
	//具体的文件系统操作函数表
	const struct file_operations	*f_op;
	//文件读写位置
	loff_t			f_pos;
};

//定义在linux-5.8.8/include/linux/path.h
struct path {
	//挂载文件系统的信息
	struct vfsmount *mnt;
	//当前目录的dentry
	struct dentry *dentry;
} __randomize_layout;

//定义在linux-5.8.8/include/linux/mount.h
//文件系统的挂载信息
struct vfsmount {
	//根目录挂载树
	struct dentry *mnt_root;	
	//指向超级块
	struct super_block *mnt_sb;	
	int mnt_flags;
} __randomize_layout;


//定义在linux-5.8.8/include/linux/dcache.h
//操作系统的目录树是采用dentry表示，这个是文件的逻辑表示方式,目录项对象首先用于按照树状组织的文件路径和文件建立联系,其次file对象通过目录项可以进一步查找文件inode,vfs把目录看成普通文件，不论具体的磁盘文件是如何实现这些目录项，其内容一旦读入到VFS中统一转换为通用的dentry目录项对象
struct dentry {
	/****忽略其中不关注的字段***/
	//当前文件的父目录
	struct dentry *d_parent;	/* parent directory */
	//当前文件的名称
	struct qstr d_name;
	//当前文件的inode信息
	struct inode *d_inode;	
	//短文件名称的存储优化
	unsigned char d_iname[DNAME_INLINE_LEN];	/* small names */
	//根据哈希表快速查找dentry,否则按照树状组织从根节点开始查找
	struct hlist_bl_node d_hash;	/* lookup hash list */
	//当前目录操作的函数表
	const struct dentry_operations *d_op;
	//指向dentry的这颗树的树根
	struct super_block *d_sb;	/* The root of the dentry tree */
} __randomize_layout;

//定义在linux-5.8.8/include/linux/fs.h
//inode描述文件的属性、存储位置等信息，涉及元数据操作以及整个文件系统对象操作，创建、删除文件等
struct inode {
	/****忽略其中不关注的字段***/
	//文件的mode
	umode_t			i_mode;
	//文件的gid/uid等信息
	kuid_t			i_uid;
	kgid_t			i_gid;
	//文件的flags信息
	unsigned int		i_flags;
	//文件的acl信息
#ifdef CONFIG_FS_POSIX_ACL
	struct posix_acl	*i_acl;
	struct posix_acl	*i_default_acl;
#endif
	//每个具体文件系统的inode的函数操作表
	const struct inode_operations	*i_op;
	//超级块指针
	struct super_block	*i_sb;
	
	//设备信息
	dev_t			i_rdev;
	//文件大小
	loff_t			i_size;
	//文件的创建、更新、修改时间
	struct timespec64	i_atime;
	struct timespec64	i_mtime;
	struct timespec64	i_ctime;

	//磁盘块号
	blkcnt_t		i_blocks;
	//文件状态信息
	unsigned long		i_state;
	void			*i_private; /* fs or device private pointer */
} __randomize_layout;
```